///////////////////////////////////////////////////////////////////////////////////
//Модуль - Serializer Вызов сервера
//
// MIT License Copyright (c) 2020 AcrylPlatform.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights 
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
// copies of the Software, and to permit persons to whom the Software 
// is furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be 
// included in all copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT 
// SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE 
// OR OTHER DEALINGS IN THE SOFTWARE.
//
///////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////
#Область ПрограммныйИнтерфейс

Функция СравнитьДваОбъекта(О1, О2, Разница = Истина) Экспорт
	
	Перем Т;

	Т = Новый ТаблицаЗначений();
	
    Т.Колонки.Добавить("Реквизит");
    Т.Колонки.Добавить("Значение1");
    Т.Колонки.Добавить("Значение2");
    Т.Колонки.Добавить("НомерСтроки");
    Т.Колонки.Добавить("ТабличнаяЧасть");
    Т.Колонки.Добавить("Разница");

	Если ТипЗнч(О1) <> ТипЗнч(О2) Тогда
		
		Возврат Неопределено;
		
    КонецЕсли;
    
	Ссылка1 = О1.Ссылка;
	
    Ссылка2 = О2.Ссылка;
    
    ЭтоСправочник = Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(Ссылка1));
    ЭтоДокумент = Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(Ссылка1));
    
    Если 
        ЭтоДокумент ИЛИ ЭтоСправочник
	Тогда 
	 
        МДО = Метаданные.НайтиПоТипу(ТипЗнч(Ссылка1));
        
		СписокРеквизитов = Новый Массив();
		
		Если ЭтоСправочник Тогда
			
            СписокРеквизитов.Добавить("Наименование");
            СписокРеквизитов.Добавить("ПометкаУдаления");
			СписокРеквизитов.Добавить("Код");
			
			Если МДО.Иерархический Тогда
				
				СписокРеквизитов.Добавить("Родитель");
				
				Если МДО.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов Тогда
					
					СписокРеквизитов.Добавить("ЭтоГруппа");
					
				КонецЕсли;
				
			КонецЕсли;
			
			Если МДО.Владельцы.Количество() <> 0 Тогда 
				
				СписокРеквизитов.Добавить("Владелец");
				
			КонецЕсли;
			
		КонецЕсли;
		
		Если ЭтоДокумент Тогда
			
            СписокРеквизитов.Добавить("Дата");
            СписокРеквизитов.Добавить("Номер");
            СписокРеквизитов.Добавить("Проведен");
			СписокРеквизитов.Добавить("ПометкаУдаления");
			
        КонецЕсли;
        
		Для Каждого МДР ИЗ МДО.Реквизиты Цикл
			
            Реквизит = МДР.Имя;
			СписокРеквизитов.Добавить(Реквизит);
			
		КонецЦикла;
		
		Для Каждого Реквизит Из СписокРеквизитов Цикл
			
            Значение1 = О1[Реквизит];
			Значение2 = О2[Реквизит];
			
			Если ТипЗнч(Значение1) = Тип("ХранилищеЗначения")
			И	 ТипЗнч(Значение2) = Тип("ХранилищеЗначения") Тогда

				Продолжить;

			КонецЕсли;
			
			Если Значение1 <> Значение2 ИЛИ НЕ Разница Тогда
				
                Стр = Т.Добавить();            
                Стр.Реквизит = Реквизит;
                Стр.Значение1 = Значение1;
				Стр.Значение2 = Значение2;
								
				Стр.Разница = Значение1 <> Значение2;			
				
			КонецЕсли;
			
        КонецЦикла;
        
		Для Каждого МДТЧ ИЗ МДО.ТабличныеЧасти Цикл
			
            ИмяТЧ = МДТЧ.Имя;
            ТЧ1 = О1[ИмяТЧ];
			ТЧ2 = О2[ИмяТЧ];
			
			Для Инд = 0 По Макс(ТЧ1.Количество() - 1, ТЧ2.Количество() - 1) Цикл
				
				Для Каждого МДРТЧ ИЗ МДТЧ.Реквизиты Цикл
					
					Реквизит = МДРТЧ.Имя;
					
					Если Инд >= ТЧ1.Количество() Тогда
						
						Значение1 = Неопределено;
						
					Иначе
						
						Значение1 = ТЧ1[Инд][Реквизит];
						
					КонецЕсли;
					
					Если Инд >= ТЧ2.Количество() Тогда
						
						Значение2 = Неопределено;
						
					Иначе
						
						Значение2 = ТЧ2[Инд][Реквизит];
						
					КонецЕсли;
					
					Если Значение1 <> Значение2 ИЛИ НЕ Разница Тогда
						
						Стр = Т.Добавить();
						            
                        Стр.Реквизит = Реквизит;
                        Стр.Значение1 = Значение1;
                        Стр.Значение2 = Значение2;
                        Стр.НомерСтроки = Инд;
                        Стр.ТабличнаяЧасть = ИмяТч;
						Стр.Разница = Значение1 <> Значение2;
						
					КонецЕсли;
					
				КонецЦикла;
				
			КонецЦикла;
			
		КонецЦикла;
		
    КонецЕсли;
    
    Возврат Т;
    
КонецФункции

Функция СерилизоватьОбъект(Значение) Экспорт
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	
	НастройкиСериализации = Новый НастройкиСериализацииJSON;
	НастройкиСериализации.ВариантЗаписиДаты  = ВариантЗаписиДатыJSON.ЛокальнаяДата;
	НастройкиСериализации.ФорматСериализацииДаты  = ФорматДатыJSON.ISO;
	
	Объект = Значение.ПолучитьОбъект();
	
	СериализаторXDTO.ЗаписатьJSON(ЗаписьJSON, Объект, НазначениеТипаXML.Явное);
	
	ДокументJson = ЗаписьJSON.Закрыть();		
	
	Хранилище = Новый ХранилищеЗначения(ДокументJson, Новый СжатиеДанных(9));
	СерилизованнаяСтрока = СериализаторXDTO.XMLСтрока(Хранилище);
	
	Результат = Новый Структура;
	
	Ключ = "ref-" + Строка(Значение.УникальныйИдентификатор());
	
	Ключ = СтрЗаменить(Ключ, "-", "_");
	
	Результат.Вставить(Ключ, СерилизованнаяСтрока);
	
	Возврат Результат;
	
КонецФункции

Функция СериализоватьВJSON(СериализуемыйОбъект) Экспорт
    
    ЗаписьJSON = Новый ЗаписьJSON; 
    ЗаписьJSON.УстановитьСтроку();
    НастройкиСериализации = Новый НастройкиСериализацииJSON();
    НастройкиСериализации.СериализовыватьМассивыКакОбъекты = Ложь;
    ЗаписатьJSON(ЗаписьJSON, СериализуемыйОбъект); 
    
    СтрокаJSON = ЗаписьJSON.Закрыть();
        
    Возврат СтрокаJSON; 

КонецФункции

Функция ПрочитатьJSONНаСервере(СтрокаJSON) Экспорт
	
	ЧтениеJSON = Новый ЧтениеJSON;    
    ЧтениеJSON.УстановитьСтроку(СтрокаJSON);
    Соответствие = ПрочитатьJSON(ЧтениеJSON, Истина);
	
	Возврат Соответствие;
	
КонецФункции

Функция ПолучитьСерилизованноеЗначение(Значение) Экспорт
	
	ХранилищеЗначения = СериализаторXDTO.XMLЗначение(Тип("ХранилищеЗначения"), Значение);
				
	Json = ХранилищеЗначения.Получить();
	
	ЧтениеJson = Новый ЧтениеJSON;
	ЧтениеJson.УстановитьСтроку(Json);
	
	ДанныеОбъекта = СериализаторXDTO.ПрочитатьJSON(ЧтениеJson);
	
	Возврат ДанныеОбъекта;
	
КонецФункции

#КонецОбласти
////////////////////////////////////////////////////////////////////////////////////
