///////////////////////////////////////////////////////////////////////////////////
//Модуль - Serializer назначения Клиент Сервер
//
// MIT License Copyright (c) 2020 AcrylPlatform.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights 
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
// copies of the Software, and to permit persons to whom the Software 
// is furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be 
// included in all copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT 
// SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE 
// OR OTHER DEALINGS IN THE SOFTWARE.
//
///////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////
#Область СлужебныеПроцедурыИФункции

///////////////////////////////////////////////////////////////////////////////////
#Область ОберткаОбщихФункций

Функция ПобитовыйСдвигВправоБеззнаковый(Число, Смещение)
	
	Возврат Crypt_ОбщегоНазначенияКлиентСевер.ПобитовыйСдвигВправоСЗаполнениемНулями(Число, Смещение);
	
КонецФункции
	
Функция пИ(Число1, Число2, Разрядность = 32, Беззнаковое = Ложь)  
	
	Возврат Crypt_ОбщегоНазначенияКлиентСевер.пИ(Число1, Число2, Разрядность, Беззнаковое);
	
КонецФункции

Функция пИли(Число1, Число2, Разрядность = 32, Беззнаковое = Ложь) 
	
	Возврат Crypt_ОбщегоНазначенияКлиентСевер.пИли(Число1, Число2, Разрядность, Беззнаковое);
	
КонецФункции

Функция ПреведениеКДиапазону(Знач ТипизированныйМассив, Знач Число) Экспорт 
	
	Возврат Crypt_ТипизированныеМассивы.ПреведениеКДиапазону(ТипизированныйМассив, Число);
	
КонецФункции

Функция floor(Знач Число)
	
	Возврат Crypt_ОбщегоНазначенияКлиентСевер.Округлить(Число);
	
КонецФункции

#КонецОбласти
///////////////////////////////////////////////////////////////////////////////////

Функция СерилизацияДанных(Данные)
	
	Если ТипЗнч(Данные) = Тип("Структура") Тогда
		
		ByteData = Crypt_ТипизированныеМассивы.Uint8Array("result");
		
		СчКлючей = 0;
		
		Для Каждого КлючЗначение Из Данные Цикл
			
			Значение = КлючЗначение.Значение;
			Ключ = КлючЗначение.Ключ;
			Результат = ByteData.result;
			
			мКлюч = Crypt_StringBytes.СтрокуВБайты(Ключ, "raw");
			
			тДлина = Неопределено;
			
			Серилизация(мКлюч.Количество(), , тДлина);
			
			Объеденение = Новый Структура("тДлина, мКлюч", 
				Crypt_ОбщегоНазначенияКлиентСевер.ОбрезатьМассив(тДлина.objBytes, 6), мКлюч);
		
			СерилизованныйКлюч = Crypt_ОбщегоНазначенияКлиентСевер.СложитьМассивы(Объеденение, Ложь);
							
			Если ТипЗнч(Значение) = Тип("Структура") Тогда 
				
				Если Значение.Свойство("ДиапазонЗначенийМин")
				   И Значение.Свойство("ДиапазонЗначенийМакс")
				   И Значение.Свойство("Разярдность") Тогда 
				   
				   Если Значение.ДиапазонЗначенийМакс > 255 
					  И Значение.ДиапазонЗначенийМин <> 0 Тогда 
					  
					  ВызватьИсключение "Supported Uint8Array Only";
					  
				   КонецЕсли;
				   
				   мЗначение = Crypt_ТипизированныеМассивы.ПолучитьДанныеМассива(Значение).Данные;
				   
				   ТипДанных = Новый Массив;
				   ТипДанных.Добавить(2);
				   
				КонецЕсли;	
				
			ИначеЕсли ТипЗнч(Значение) = Тип("Строка") Тогда 
				
				мЗначение = Crypt_StringBytes.СтрокуВБайты(Значение, "raw");
				
				ТипДанных = Новый Массив;
				ТипДанных.Добавить(3);
				
			ИначеЕсли ТипЗнч(Значение) = Тип("Булево") Тогда 
				
				мЗначение = Новый Массив;
				
				мЗначение.Добавить(?(Значение, 1, 0));
				
				ТипДанных = Новый Массив;
				ТипДанных.Добавить(1);
				
			ИначеЕсли ТипЗнч(Значение) = Тип("Число") Тогда
				
				мЗначение = ПреобразованиеЧиселВБайты(ПреобразованиеЧисел(Значение));
				
				ТипДанных = Новый Массив;
				ТипДанных.Добавить(0);
				
			КонецЕсли;
			
			Если ТипЗнч(Значение) <> Тип("Булево")
			И    ТипЗнч(Значение) <> Тип("Число") Тогда 
			
				тДлина = Неопределено;
				
				Серилизация(мЗначение.Количество(), , тДлина);
				
				Объеденение = Новый Структура("тДлина, мЗначение", 
					Crypt_ОбщегоНазначенияКлиентСевер.ОбрезатьМассив(тДлина.objBytes, 6), мЗначение);
			
				СерилизованныеДанные = Crypt_ОбщегоНазначенияКлиентСевер.СложитьМассивы(Объеденение, Ложь);
				
			Иначе
				
				СерилизованныеДанные = мЗначение;	
				
			КонецЕсли;	
				
			Объеденение = Новый Структура("СерилизованныйКлюч, ТипДанных, СерилизованныеДанные", 
				СерилизованныйКлюч, ТипДанных, СерилизованныеДанные);
				
			СерилизованныеКлючТипЗначение = Crypt_ОбщегоНазначенияКлиентСевер.СложитьМассивы(Объеденение, Ложь);
			
			Объеденение = Новый Структура("Результат, СерилизованныеКлючТипЗначение", 
				Результат, СерилизованныеКлючТипЗначение);

			ByteData.result = Crypt_ОбщегоНазначенияКлиентСевер.СложитьМассивы(Объеденение, Ложь);
			
			СчКлючей = СчКлючей + 1;
			
		КонецЦикла;	
		
		тДлина = Неопределено;
		
		Серилизация(СчКлючей, , тДлина);
		
		Объеденение = Новый Структура("тДлина, ByteData", 
			Crypt_ОбщегоНазначенияКлиентСевер.ОбрезатьМассив(тДлина.objBytes, 6), ByteData.result);
			
		ByteData.result = Crypt_ОбщегоНазначенияКлиентСевер.СложитьМассивы(Объеденение, Ложь);
	
	КонецЕсли;
	
	Возврат ByteData;
	
КонецФункции

Функция ПреобразованиеЧисел(value, unsigned = Неопределено)
	
	Если value > Pow(2, 53) - 1 	Тогда 
		
		ВызватьИсключение "Error " + value + " is too big to be precisely represented";
		
	КонецЕсли;
	
	UZERO = Новый Структура("low, high, unsigned", 0, 0, Истина);
	ZERO = Новый Структура("low, high, unsigned", 0, 0, Ложь);
	
	TWO_PWR_64_DBL = 18446744073709552000;
	TWO_PWR_63_DBL = 9223372036854776000;
	
	MAX_UNSIGNED_VALUE = Новый Структура("low, high, unsigned", -1, -1, Истина);
	
	
	MIN_VALUE = Новый Структура("low, high, unsigned", 0, -2147483648, Ложь);
	MAX_VALUE = Новый Структура("low, high, unsigned", -1, 2147483647, Ложь);
	
	TWO_PWR_32_DBL = 4294967296;
	
	Если value = Неопределено Тогда 
		
		Возврат ?(unsigned,  UZERO, ZERO);
		
	КонецЕсли;
	
	Если unsigned = Истина Тогда 

		Если value < 0 Тогда

			Возврат UZERO;

		КонецЕсли;

		Если value >= TWO_PWR_64_DBL Тогда 

			Возврат MAX_UNSIGNED_VALUE;

		КонецЕсли;

	Иначе 

		Если value <= -TWO_PWR_63_DBL Тогда 
	
			Возврат MIN_VALUE;

		КонецЕсли;


		Если value + 1 >= TWO_PWR_63_DBL Тогда 

			Возврат MAX_VALUE;

		КонецЕсли;

	КонецЕсли;

	//long.js 169
	
	Возврат Новый Структура("low, high, unsigned", 
		пИли((value % TWO_PWR_32_DBL), 0), пИли(floor(value / TWO_PWR_32_DBL), 0), unsigned);
	
КонецФункции

Функция ПреобразованиеЧиселВБайты(СтруктураОбъекта)
	
	hi = СтруктураОбъекта.high;
	lo = СтруктураОбъекта.low;
	
	Результат_t = Crypt_ТипизированныеМассивы.Uint8Array("Результат");
	
    Результат = Результат_t.Результат;
	
	Результат.Добавить(ПреведениеКДиапазону(Результат_t,
		ПобитовыйСдвигВправоБеззнаковый(hi, 24)));
	Результат.Добавить(ПреведениеКДиапазону(Результат_t,
		ПобитовыйСдвигВправоБеззнаковый(hi, пИ(16, 255))));
	Результат.Добавить(ПреведениеКДиапазону(Результат_t,
		ПобитовыйСдвигВправоБеззнаковый(hi, пИ(8, 255))));
	Результат.Добавить(ПреведениеКДиапазону(Результат_t,
		пИ(hi, 255)));
	Результат.Добавить(ПреведениеКДиапазону(Результат_t, 
		ПобитовыйСдвигВправоБеззнаковый(lo, 24)));
	Результат.Добавить(ПреведениеКДиапазону(Результат_t, 
		ПобитовыйСдвигВправоБеззнаковый(lo, пИ(16, 255))));
	Результат.Добавить(ПреведениеКДиапазону(Результат_t, 
		ПобитовыйСдвигВправоБеззнаковый(lo, пИ(8, 255))));
	Результат.Добавить(ПреведениеКДиапазону(Результат_t,
		пИ(lo, 255)));                                 
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти 
///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
#Область ПрограммныйИнтерфейс 

Функция Серилизация(вхДанные, Ключ = "", Результат = Неопределено) Экспорт
	
	Если Результат = Неопределено Тогда 
		
		Результат = Crypt_ТипизированныеМассивы.Uint8Array("objBytes");
		
	КонецЕсли;
	
	objBytes = Результат.objBytes;
	
	Если ТипЗнч(вхДанные) = Тип("Структура") Тогда 
					
		Для Каждого КлючЗначение Из вхДанные Цикл
			
			Значение = КлючЗначение.Значение;
			Ключ = КлючЗначение.Ключ;
			
			Если Ключ = "data" Тогда 
				
				ByteData = СерилизацияДанных(Значение);
				
				Объеденение = Новый Структура("objBytes, result", Результат.objBytes, ByteData.result);
		
				Результат.objBytes = Crypt_ОбщегоНазначенияКлиентСевер.СложитьМассивы(Объеденение, Ложь);

				
			Иначе	
				
				Серилизация(Значение, Ключ, Результат);
				
			КонецЕсли;
			
		КонецЦикла;
		
		Возврат Результат;
		
	ИначеЕсли Ключ = "type" Или Ключ = "version" Тогда 
		
		objBytes.Добавить(вхДанные);
		
	ИначеЕсли Ключ = "senderPublicKey" Тогда
		
		ПубличныйКлюч = Crypt_Base58.base58_decode(вхДанные);
		
		Объеденение = Новый Структура("objBytes, ПубличныйКлюч", objBytes, ПубличныйКлюч);
		
		Результат.objBytes = Crypt_ОбщегоНазначенияКлиентСевер.СложитьМассивы(Объеденение, Ложь);
		
	ИначеЕсли Ключ = "recipient" Тогда
		
		Адрес = Crypt_Base58.base58_decode(вхДанные);
		
		Объеденение = Новый Структура("objBytes, Адрес", objBytes, Адрес);
		
		Результат.objBytes = Crypt_ОбщегоНазначенияКлиентСевер.СложитьМассивы(Объеденение, Ложь);
		
		
	ИначеЕсли вхДанные = Неопределено Тогда 
		
		 objBytes.Добавить(0);
		 
	ИначеЕсли ТипЗнч(вхДанные) = Тип("Число") Тогда 
		 
		mBytes = ПреобразованиеЧиселВБайты(ПреобразованиеЧисел(вхДанные));
		
		Объеденение = Новый Структура("objBytes, mBytes", objBytes, mBytes);
		
		Результат.objBytes = Crypt_ОбщегоНазначенияКлиентСевер.СложитьМассивы(Объеденение, Ложь);
		
	ИначеЕсли ТипЗнч(вхДанные) = Тип("Строка") Тогда	
		
		Данные = Crypt_Base58.base58_decode(вхДанные);	
		
		КоличествоЭлементов = Данные.Количество();
		
		mBytes = ПреобразованиеЧиселВБайты(ПреобразованиеЧисел(КоличествоЭлементов));
						
		mBytes = Crypt_ОбщегоНазначенияКлиентСевер.ОбрезатьМассив(mBytes, 6);
		
		Объеденение = Новый Структура("mBytes, Данные", mBytes, Данные);
		
		mStr = Crypt_ОбщегоНазначенияКлиентСевер.СложитьМассивы(Объеденение, Ложь);
		
		Объеденение = Новый Структура("objBytes, mStr", objBytes, mStr);
		
		Результат.objBytes = Crypt_ОбщегоНазначенияКлиентСевер.СложитьМассивы(Объеденение, Ложь);		
		
	КонецЕсли;
		
КонецФункции

#КонецОбласти
///////////////////////////////////////////////////////////////////////////////////


